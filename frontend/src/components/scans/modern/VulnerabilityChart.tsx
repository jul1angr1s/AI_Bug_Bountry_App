import { useMemo } from 'react';
import type { Finding } from '../../../lib/api';

export interface ChartDataPoint {
  timestamp: number;
  count: number;
  cumulativeCount: number;
}

export interface VulnerabilityChartProps {
  findings: Finding[];
  className?: string;
}

/**
 * Build chart data by grouping findings into 5-minute intervals and calculating cumulative counts
 */
function buildChartData(findings: Finding[]): ChartDataPoint[] {
  if (!findings || findings.length === 0) {
    return [];
  }

  // Sort findings by timestamp
  const sortedFindings = [...findings].sort(
    (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
  );

  const firstTimestamp = new Date(sortedFindings[0].createdAt).getTime();
  const lastTimestamp = new Date(sortedFindings[sortedFindings.length - 1].createdAt).getTime();
  const now = Date.now();

  // Use current time as end if scan is still running
  const endTimestamp = Math.max(lastTimestamp, now);

  // Create 5-minute buckets (300000ms = 5 minutes)
  const bucketSize = 5 * 60 * 1000;
  const buckets = new Map<number, number>();

  // Initialize buckets from first finding to now
  const startBucket = Math.floor(firstTimestamp / bucketSize) * bucketSize;
  const endBucket = Math.floor(endTimestamp / bucketSize) * bucketSize;

  for (let bucket = startBucket; bucket <= endBucket; bucket += bucketSize) {
    buckets.set(bucket, 0);
  }

  // Count findings in each bucket
  sortedFindings.forEach(finding => {
    const timestamp = new Date(finding.createdAt).getTime();
    const bucket = Math.floor(timestamp / bucketSize) * bucketSize;
    buckets.set(bucket, (buckets.get(bucket) || 0) + 1);
  });

  // Calculate cumulative counts
  const dataPoints: ChartDataPoint[] = [];
  let cumulative = 0;

  Array.from(buckets.keys()).sort((a, b) => a - b).forEach(bucket => {
    const count = buckets.get(bucket) || 0;
    cumulative += count;
    dataPoints.push({
      timestamp: bucket,
      count,
      cumulativeCount: cumulative,
    });
  });

  return dataPoints;
}

/**
 * Format time difference from first data point
 */
function formatTimeLabel(timestamp: number, startTimestamp: number): string {
  const diffMs = timestamp - startTimestamp;
  const diffMinutes = Math.floor(diffMs / 60000);

  if (diffMinutes < 60) {
    return `${diffMinutes}m`;
  }

  const hours = Math.floor(diffMinutes / 60);
  const minutes = diffMinutes % 60;
  return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
}

/**
 * Get time window description based on scan duration
 */
function getTimeWindowLabel(startTimestamp: number, endTimestamp: number): string {
  const durationMs = endTimestamp - startTimestamp;
  const durationMinutes = Math.floor(durationMs / 60000);

  if (durationMinutes <= 30) {
    return `Issues found over the last ${durationMinutes} minutes`;
  }

  if (durationMinutes < 60) {
    return `Issues found over the last ${durationMinutes} minutes`;
  }

  const hours = Math.floor(durationMinutes / 60);
  const minutes = durationMinutes % 60;
  if (minutes === 0) {
    return `Issues found over the last ${hours} hour${hours > 1 ? 's' : ''}`;
  }
  return `Issues found over the last ${hours}h ${minutes}m`;
}

/**
 * Generate SVG path for line chart with smooth curves
 */
function generateLinePath(points: Array<{ x: number; y: number }>): string {
  if (points.length === 0) return '';
  if (points.length === 1) {
    // For single point, draw a horizontal line
    return `M 0,${points[0].y} L ${points[0].x},${points[0].y}`;
  }

  // Start at first point
  let path = `M ${points[0].x},${points[0].y}`;

  // Use quadratic bezier curves for smooth line
  for (let i = 1; i < points.length; i++) {
    const prev = points[i - 1];
    const curr = points[i];

    // Control point is midway between points
    const cx = (prev.x + curr.x) / 2;
    const cy = (prev.y + curr.y) / 2;

    path += ` Q ${cx},${prev.y} ${cx},${cy}`;
    path += ` Q ${cx},${curr.y} ${curr.x},${curr.y}`;
  }

  return path;
}

/**
 * Generate SVG path for area fill (same as line path but closed)
 */
function generateAreaPath(points: Array<{ x: number; y: number }>, height: number): string {
  if (points.length === 0) return '';

  const linePath = generateLinePath(points);

  // Close the path by going to bottom-right, then bottom-left
  const lastPoint = points[points.length - 1];
  const firstPoint = points[0];

  return `${linePath} L ${lastPoint.x},${height} L ${firstPoint.x},${height} Z`;
}

export default function VulnerabilityChart({ findings, className = '' }: VulnerabilityChartProps) {
  const chartData = useMemo(() => buildChartData(findings), [findings]);

  // Chart dimensions
  const width = 478;
  const height = 120;
  const padding = { top: 20, right: 20, bottom: 30, left: 20 };
  const chartWidth = width - padding.left - padding.right;
  const chartHeight = height - padding.top - padding.bottom;

  // Calculate total count and new count (last 5 minutes)
  const totalCount = findings?.length || 0;
  const now = Date.now();
  const fiveMinutesAgo = now - 5 * 60 * 1000;
  const recentCount = findings?.filter(f => new Date(f.createdAt).getTime() >= fiveMinutesAgo).length || 0;

  // Empty state
  if (chartData.length === 0) {
    const emptyPath = `M ${padding.left},${height - padding.bottom} L ${width - padding.right},${height - padding.bottom}`;

    return (
      <div className={`bg-surface-dark border border-surface-border rounded-lg p-6 ${className}`}>
        <div className="flex items-start justify-between mb-4">
          <div>
            <h3 className="text-lg font-semibold text-white mb-1">Vulnerability Detection Rate</h3>
            <p className="text-sm text-gray-400">No vulnerabilities detected yet</p>
          </div>
          <div className="text-right">
            <div className="text-3xl font-bold text-white">0</div>
          </div>
        </div>

        <div className="relative">
          <svg
            width={width}
            height={height}
            viewBox={`0 0 ${width} ${height}`}
            className="w-full h-auto"
            aria-label="Line chart showing 0 vulnerabilities detected"
            role="img"
          >
            <defs>
              <linearGradient id="chartGradient" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0%" stopColor="#0663f9" stopOpacity="0.3" />
                <stop offset="100%" stopColor="#0663f9" stopOpacity="0" />
              </linearGradient>
            </defs>

            {/* Flat line at zero */}
            <path
              d={emptyPath}
              stroke="#0663f9"
              strokeWidth="2"
              strokeLinecap="round"
              fill="none"
            />

            {/* X-axis labels */}
            <text x={padding.left} y={height - 5} fill="#6b7280" fontSize="12" textAnchor="start">
              0m
            </text>
            <text x={width - padding.right} y={height - 5} fill="#6b7280" fontSize="12" textAnchor="end">
              now
            </text>
          </svg>
        </div>
      </div>
    );
  }

  // Calculate scales
  const maxCount = Math.max(...chartData.map(d => d.cumulativeCount));
  const minTimestamp = chartData[0].timestamp;
  const maxTimestamp = chartData[chartData.length - 1].timestamp;
  const timeRange = maxTimestamp - minTimestamp || 1; // Avoid division by zero

  // Map data points to SVG coordinates
  const points = chartData.map(d => ({
    x: padding.left + ((d.timestamp - minTimestamp) / timeRange) * chartWidth,
    y: padding.top + chartHeight - (d.cumulativeCount / maxCount) * chartHeight,
  }));

  // Generate paths
  const linePath = generateLinePath(points);
  const areaPath = generateAreaPath(points, height - padding.bottom);

  // Last point for endpoint circle
  const lastPoint = points[points.length - 1];

  // Time window label
  const timeWindowLabel = getTimeWindowLabel(minTimestamp, Math.max(maxTimestamp, now));

  // X-axis labels (0m, middle, end)
  const middleTimestamp = minTimestamp + timeRange / 2;
  const endTimestamp = Math.max(maxTimestamp, now);

  // Generate ARIA label
  const ariaLabel = `Line chart showing ${totalCount} vulnerabilities detected over ${Math.floor((endTimestamp - minTimestamp) / 60000)} minutes`;

  return (
    <div className={`bg-surface-dark border border-surface-border rounded-lg p-6 ${className}`}>
      <div className="flex items-start justify-between mb-4">
        <div>
          <h3 className="text-lg font-semibold text-white mb-1">Vulnerability Detection Rate</h3>
          <p className="text-sm text-gray-400">{timeWindowLabel}</p>
        </div>
        <div className="text-right">
          <div className="text-3xl font-bold text-white">{totalCount}</div>
          {recentCount > 0 && (
            <div className="flex items-center justify-end gap-1 mt-1">
              <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-green-500/10 text-green-500 text-xs font-medium">
                <span className="material-symbols-outlined text-sm">trending_up</span>
                +{recentCount} new
              </span>
            </div>
          )}
        </div>
      </div>

      <div className="relative">
        <svg
          width={width}
          height={height}
          viewBox={`0 0 ${width} ${height}`}
          className="w-full h-auto"
          aria-label={ariaLabel}
          role="img"
        >
          <defs>
            <linearGradient id="chartGradient" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0%" stopColor="#0663f9" stopOpacity="0.3" />
              <stop offset="100%" stopColor="#0663f9" stopOpacity="0" />
            </linearGradient>
          </defs>

          {/* Area fill */}
          <path
            d={areaPath}
            fill="url(#chartGradient)"
          />

          {/* Line path */}
          <path
            d={linePath}
            stroke="#0663f9"
            strokeWidth="2"
            strokeLinecap="round"
            fill="none"
          />

          {/* Endpoint circle */}
          <circle
            cx={lastPoint.x}
            cy={lastPoint.y}
            r="4"
            fill="white"
            stroke="#0663f9"
            strokeWidth="2"
          />

          {/* X-axis labels */}
          <text x={padding.left} y={height - 5} fill="#6b7280" fontSize="12" textAnchor="start">
            0m
          </text>
          <text
            x={padding.left + chartWidth / 2}
            y={height - 5}
            fill="#6b7280"
            fontSize="12"
            textAnchor="middle"
          >
            {formatTimeLabel(middleTimestamp, minTimestamp)}
          </text>
          <text x={width - padding.right} y={height - 5} fill="#6b7280" fontSize="12" textAnchor="end">
            {formatTimeLabel(endTimestamp, minTimestamp)}
          </text>
        </svg>
      </div>
    </div>
  );
}
